/**
 * Optimize Blog Keywords - Supabase Edge Function
 *
 * This function uses Google Gemini AI to generate SEO-optimized keywords,
 * tags, meta descriptions, and slugs for blog posts.
 *
 * HOW IT WORKS:
 * 1. Receives blog post title and content
 * 2. Calls Google Gemini AI API
 * 3. Generates 5-10 SEO keywords, 3-5 tags, meta description, and slug
 * 4. Returns structured JSON response
 *
 * REQUEST BODY:
 * {
 *   "title": "Blog Post Title",
 *   "content": "Blog post content...",
 *   "excerpt": "Optional excerpt" // optional
 * }
 *
 * RESPONSE:
 * {
 *   "success": true,
 *   "keywords": ["keyword1", "keyword2", ...],
 *   "tags": ["tag1", "tag2", ...],
 *   "meta_description": "150-160 character description",
 *   "slug": "optimized-url-slug"
 * }
 */

import { serve } from 'https://deno.land/std@0.177.0/http/server.ts';
import { getCorsHeaders, handleCorsPreflightRequest, jsonResponse, errorResponse } from '../_shared/cors.ts';
import { sanitizeSlug } from '../_shared/utils.ts';

// Environment variables
const GEMINI_API_KEY = Deno.env.get('GEMINI_API_KEY');
const GEMINI_MODEL = 'gemini-1.5-flash'; // Fast and efficient model

interface OptimizationResult {
  keywords: string[];
  tags: string[];
  meta_description: string;
  slug: string;
}

/**
 * Call Google Gemini AI to optimize blog content
 */
async function optimizeWithGemini(
  title: string,
  content: string,
  excerpt?: string
): Promise<OptimizationResult> {
  if (!GEMINI_API_KEY) {
    throw new Error('GEMINI_API_KEY not configured');
  }

  console.log('Calling Google Gemini AI for optimization...');

  // Strip HTML from content for better analysis
  const plainContent = content.replace(/<[^>]*>/g, ' ').replace(/\s+/g, ' ').trim();

  // Truncate content to first 1000 words to stay within token limits
  const words = plainContent.split(' ');
  const truncatedContent = words.slice(0, 1000).join(' ');

  // Construct the prompt
  const prompt = `You are an SEO expert. Analyze the following blog post and generate optimized SEO elements.

Title: ${title}

${excerpt ? `Excerpt: ${excerpt}\n` : ''}
Content: ${truncatedContent}${words.length > 1000 ? '...' : ''}

Generate the following in JSON format:
1. "keywords": Array of 5-10 highly relevant SEO keywords and phrases (focus on search intent)
2. "tags": Array of 3-5 concise tags/categories for the blog post
3. "meta_description": A compelling meta description (150-160 characters) that includes primary keywords
4. "slug": An optimized URL slug (lowercase, hyphens, max 60 characters, includes primary keyword)

Return ONLY valid JSON, no other text. Example format:
{
  "keywords": ["keyword1", "keyword2"],
  "tags": ["tag1", "tag2"],
  "meta_description": "Description here",
  "slug": "optimized-slug"
}`;

  // Call Gemini API
  const url = `https://generativelanguage.googleapis.com/v1beta/models/${GEMINI_MODEL}:generateContent?key=${GEMINI_API_KEY}`;

  const response = await fetch(url, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      contents: [
        {
          parts: [
            {
              text: prompt,
            },
          ],
        },
      ],
      generationConfig: {
        temperature: 0.7,
        maxOutputTokens: 1024,
      },
    }),
  });

  if (!response.ok) {
    const errorText = await response.text();
    console.error('Gemini API error:', response.status, errorText);
    throw new Error(`Gemini API error: ${response.status}`);
  }

  const result = await response.json();

  console.log('Gemini API response received');

  // Extract generated text
  const generatedText = result.candidates?.[0]?.content?.parts?.[0]?.text;

  if (!generatedText) {
    console.error('No text generated by Gemini');
    throw new Error('No content generated by AI');
  }

  console.log('Generated text:', generatedText);

  // Parse JSON from the response
  // Sometimes Gemini wraps JSON in markdown code blocks
  let jsonText = generatedText.trim();

  // Remove markdown code blocks if present
  if (jsonText.startsWith('```json')) {
    jsonText = jsonText.replace(/^```json\n/, '').replace(/\n```$/, '');
  } else if (jsonText.startsWith('```')) {
    jsonText = jsonText.replace(/^```\n/, '').replace(/\n```$/, '');
  }

  try {
    const optimization: OptimizationResult = JSON.parse(jsonText);

    // Validate the response
    if (!optimization.keywords || !Array.isArray(optimization.keywords)) {
      throw new Error('Invalid keywords format');
    }
    if (!optimization.tags || !Array.isArray(optimization.tags)) {
      throw new Error('Invalid tags format');
    }
    if (!optimization.meta_description || typeof optimization.meta_description !== 'string') {
      throw new Error('Invalid meta_description format');
    }
    if (!optimization.slug || typeof optimization.slug !== 'string') {
      throw new Error('Invalid slug format');
    }

    // Ensure slug is properly sanitized
    optimization.slug = sanitizeSlug(optimization.slug);

    // Truncate meta description if too long
    if (optimization.meta_description.length > 160) {
      optimization.meta_description = optimization.meta_description.substring(0, 157) + '...';
    }

    // Limit keywords to 10
    if (optimization.keywords.length > 10) {
      optimization.keywords = optimization.keywords.slice(0, 10);
    }

    // Limit tags to 5
    if (optimization.tags.length > 5) {
      optimization.tags = optimization.tags.slice(0, 5);
    }

    console.log('Optimization successful:', optimization);

    return optimization;
  } catch (parseError) {
    console.error('Failed to parse Gemini response:', parseError);
    console.error('Raw response:', jsonText);
    throw new Error('Failed to parse AI response. Please try again.');
  }
}

/**
 * Fallback optimization using simple heuristics
 * Used when AI is unavailable
 */
function fallbackOptimization(title: string, content: string): OptimizationResult {
  console.log('Using fallback optimization');

  // Generate slug from title
  const slug = sanitizeSlug(title);

  // Extract potential keywords from title and content
  const words = (title + ' ' + content)
    .toLowerCase()
    .replace(/<[^>]*>/g, ' ')
    .replace(/[^\w\s]/g, ' ')
    .split(/\s+/)
    .filter(word => word.length > 4); // Only words longer than 4 characters

  // Count word frequency
  const wordFreq: { [key: string]: number } = {};
  words.forEach(word => {
    wordFreq[word] = (wordFreq[word] || 0) + 1;
  });

  // Get top keywords by frequency
  const sortedWords = Object.entries(wordFreq)
    .sort((a, b) => b[1] - a[1])
    .map(([word]) => word);

  const keywords = sortedWords.slice(0, 10);
  const tags = sortedWords.slice(0, 5);

  // Generate meta description from first 160 characters
  const plainText = content.replace(/<[^>]*>/g, ' ').replace(/\s+/g, ' ').trim();
  let metaDescription = plainText.substring(0, 157);

  if (plainText.length > 157) {
    metaDescription += '...';
  }

  return {
    keywords,
    tags,
    meta_description: metaDescription || title,
    slug,
  };
}

serve(async (req: Request) => {
  const origin = req.headers.get('origin');

  // Handle CORS preflight requests
  if (req.method === 'OPTIONS') {
    return handleCorsPreflightRequest(req);
  }

  // Only accept POST requests
  if (req.method !== 'POST') {
    return errorResponse('Method not allowed', 405, origin);
  }

  try {
    console.log('=== Optimize Blog Keywords Request ===');

    // Parse request body
    const body = await req.json();
    const { title, content, excerpt } = body;

    if (!title || !content) {
      return errorResponse('Missing title or content', 400, origin);
    }

    console.log('Title:', title);
    console.log('Content length:', content.length);

    // Optimize using Gemini AI (with fallback)
    let optimization: OptimizationResult;

    try {
      optimization = await optimizeWithGemini(title, content, excerpt);
    } catch (error) {
      console.error('Gemini optimization failed, using fallback:', error);

      // Use fallback if AI fails
      optimization = fallbackOptimization(title, content);
    }

    // Return success response
    return jsonResponse(
      {
        success: true,
        ...optimization,
      },
      200,
      origin
    );
  } catch (error) {
    console.error('Optimize keywords error:', error);
    const errorMsg = error instanceof Error ? error.message : 'Internal server error';
    return errorResponse(errorMsg, 500, origin);
  }
});
